"""Interaction provider implementations for PentestGPT."""

from __future__ import annotations

import threading
import uuid
from dataclasses import dataclass
from typing import Any, Callable, Dict, List, Optional

from prompt_toolkit.formatted_text import HTML
from prompt_toolkit.shortcuts import confirm

from pentestgpt.utils.prompt_select import prompt_ask, prompt_select
from pentestgpt.utils.task_handler import (
    localTaskCompleter,
    local_task_entry,
    mainTaskCompleter,
    main_task_entry,
)


MAIN_TASK_OPTIONS = list(mainTaskCompleter.tasks)
LOCAL_TASK_OPTIONS = list(localTaskCompleter.tasks)


class BaseInteractionProvider:
    """Interface for collecting user input required by pentestGPT."""

    def select_main_task(self) -> str:
        raise NotImplementedError

    def select_local_task(self) -> str:
        raise NotImplementedError

    def prompt_text(self, prompt: str, *, multiline: bool) -> str:
        raise NotImplementedError

    def choose_source(self, title: str, options: List[str], descriptions: List[str]) -> int:
        raise NotImplementedError

    def confirm(self, message: str) -> bool:
        raise NotImplementedError

    def choose_from_list(self, prompt: str, options: List[str]) -> Optional[int]:
        raise NotImplementedError

    def wait_for_enter(self, message: Optional[str] = None) -> None:
        raise NotImplementedError


class PromptToolkitInteractionProvider(BaseInteractionProvider):
    """Default CLI interaction provider backed by prompt_toolkit."""

    def select_main_task(self) -> str:
        return main_task_entry()

    def select_local_task(self) -> str:
        return local_task_entry()

    def prompt_text(self, prompt: str, *, multiline: bool) -> str:
        return prompt_ask(prompt, multiline=multiline)

    def choose_source(self, title: str, options: List[str], descriptions: List[str]) -> int:
        value_list = [
            (
                idx,
                HTML(
                    f'<style fg="cyan">{options[idx]}</style>'
                    f'<style fg="LightSeaGreen">{descriptions[idx]}</style>'
                ),
            )
            for idx in range(len(options))
        ]
        selection = prompt_select(title=title, values=value_list)
        return int(selection)

    def confirm(self, message: str) -> bool:
        return bool(confirm(message))

    def choose_from_list(self, prompt: str, options: List[str]) -> Optional[int]:
        while True:
            try:
                raw = input(prompt)
            except EOFError:
                return None
            raw = raw.strip()
            if raw == "":
                return None
            try:
                idx = int(raw)
            except ValueError:
                print("Invalid option. Please enter an integer index.")
                continue
            if 0 <= idx < len(options):
                return idx
            print("Invalid option. Please enter an integer index from the list.")

    def wait_for_enter(self, message: Optional[str] = None) -> None:
        _ = input(message or "")


@dataclass
class SessionEvent:
    type: str
    payload: Dict[str, Any]
    request_id: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        data = {"type": self.type, "payload": self.payload}
        if self.request_id is not None:
            data["request_id"] = self.request_id
        return data


class _PendingResponse:
    def __init__(self) -> None:
        self.value: Any = None
        self.error: Optional[BaseException] = None
        self.event = threading.Event()

    def set_value(self, value: Any) -> None:
        self.value = value
        self.event.set()

    def set_error(self, error: BaseException) -> None:
        self.error = error
        self.event.set()

    def wait(self) -> Any:
        self.event.wait()
        if self.error is not None:
            raise self.error
        return self.value


class EventDrivenInteractionProvider(BaseInteractionProvider):
    """Interaction provider that emits structured events and waits for responses."""

    def __init__(self, emit_event: Callable[[SessionEvent], None]) -> None:
        self._emit_event = emit_event
        self._pending: Dict[str, _PendingResponse] = {}
        self._lock = threading.Lock()
        self._shutdown_error: Optional[BaseException] = None

    def select_main_task(self) -> str:
        return self._request("main_task", {"options": MAIN_TASK_OPTIONS})

    def select_local_task(self) -> str:
        return self._request("local_task", {"options": LOCAL_TASK_OPTIONS})

    def prompt_text(self, prompt: str, *, multiline: bool) -> str:
        return self._request("prompt_text", {"prompt": prompt, "multiline": multiline})

    def choose_source(self, title: str, options: List[str], descriptions: List[str]) -> int:
        return int(
            self._request(
                "option_select",
                {"title": title, "options": options, "descriptions": descriptions},
            )
        )

    def confirm(self, message: str) -> bool:
        return bool(self._request("confirm", {"prompt": message}))

    def choose_from_list(self, prompt: str, options: List[str]) -> Optional[int]:
        return self._request("list_select", {"prompt": prompt, "options": options})

    def wait_for_enter(self, message: Optional[str] = None) -> None:
        self._request("wait_for_enter", {"prompt": message or "Press Enter to continue"})

    def deliver_response(self, request_id: str, value: Any) -> None:
        with self._lock:
            pending = self._pending.get(request_id)
        if not pending:
            raise KeyError(f"Unknown request id {request_id}")
        pending.set_value(value)

    def cancel_all(self, error: Optional[BaseException] = None) -> None:
        error = error or RuntimeError("Session stopped")
        with self._lock:
            self._shutdown_error = error
            for pending in self._pending.values():
                pending.set_error(error)
            self._pending.clear()

    def _request(self, kind: str, payload: Dict[str, Any]) -> Any:
        if self._shutdown_error:
            raise self._shutdown_error
        request_id = uuid.uuid4().hex
        pending = _PendingResponse()
        with self._lock:
            self._pending[request_id] = pending
        event = SessionEvent(type="request", payload={"kind": kind, **payload}, request_id=request_id)
        self._emit_event(event)
        try:
            return pending.wait()
        finally:
            with self._lock:
                self._pending.pop(request_id, None)
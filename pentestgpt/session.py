"""High-level PentestGPT session wrapper with pluggable I/O."""

from __future__ import annotations

import contextlib
import io
import threading
from typing import Any, Callable, Dict, Optional

from rich.console import Console

from pentestgpt.interactions import (
    BaseInteractionProvider,
    EventDrivenInteractionProvider,
    SessionEvent,
)
from pentestgpt.utils.pentest_gpt import pentestGPT


_ALLOWED_AGENT_CONFIG = {
    "log_dir",
    "reasoning_model",
    "parsing_model",
    "useAPI",
    "use_langfuse_logging",
}


class _ConsoleStream(io.TextIOBase):
    def __init__(self, emit: Callable[[SessionEvent], None]) -> None:
        self._emit = emit

    def write(self, data: str) -> int:  # type: ignore[override]
        if data:
            self._emit(SessionEvent(type="output", payload={"text": data}))
        return len(data)

    def flush(self) -> None:  # type: ignore[override]
        return


class PentestGPTSession:
    def __init__(
        self,
        *,
        config: Dict[str, Any],
        event_callback: Optional[Callable[[Dict[str, Any]], None]] = None,
        io_provider: Optional[BaseInteractionProvider] = None,
        console: Optional[Console] = None,
    ) -> None:
        self._event_callback = event_callback
        self._io_provider = io_provider or (
            EventDrivenInteractionProvider(self._emit_event)
            if event_callback
            else None
        )
        if self._io_provider is None:
            raise ValueError(
                "io_provider must be supplied when no event_callback is provided"
            )

        self._console_stream = _ConsoleStream(self._emit_event) if event_callback else None
        if self._console_stream is not None:
            self._console = console or Console(
                file=self._console_stream,
                force_terminal=False,
                color_system=None,
                markup=False,
                highlight=False,
            )
        else:
            self._console = console or Console()

        agent_config = {key: value for key, value in config.items() if key in _ALLOWED_AGENT_CONFIG}
        self._agent = pentestGPT(io_provider=self._io_provider, console=self._console, **agent_config)
        self._thread: Optional[threading.Thread] = None

    def start(self) -> None:
        if self._event_callback is None:
            raise RuntimeError("event_callback is required for threaded sessions")
        if self._thread and self._thread.is_alive():
            raise RuntimeError("Session already running")
        self._emit_event(SessionEvent(type="state", payload={"status": "starting"}))
        self._thread = threading.Thread(target=self._run_thread, daemon=True)
        self._thread.start()

    def run(self) -> None:
        if self._thread and self._thread.is_alive():
            raise RuntimeError("Session already running")
        self._emit_event(SessionEvent(type="state", payload={"status": "starting"}))
        self._execute()

    def respond(self, request_id: str, value: Any) -> None:
        if not hasattr(self._io_provider, "deliver_response"):
            raise RuntimeError("Current IO provider does not accept async responses")
        self._io_provider.deliver_response(request_id, value)

    def stop(self) -> None:
        if hasattr(self._io_provider, "cancel_all"):
            self._io_provider.cancel_all(RuntimeError("Session stopped"))

    def _run_thread(self) -> None:
        self._execute()

    def _execute(self) -> None:
        self._emit_event(SessionEvent(type="state", payload={"status": "running"}))
        try:
            if self._console_stream is None:
                self._agent.main()
            else:
                with contextlib.redirect_stdout(self._console_stream), contextlib.redirect_stderr(
                    self._console_stream
                ):
                    self._agent.main()
        except Exception as exc:  # pragma: no cover
            self._emit_event(SessionEvent(type="error", payload={"message": str(exc)}))
        finally:
            self._emit_event(SessionEvent(type="state", payload={"status": "stopped"}))

    def _emit_event(self, event: SessionEvent) -> None:
        if self._event_callback is not None:
            self._event_callback(event.to_dict())
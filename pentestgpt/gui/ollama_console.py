"""Minimal PySide6 GUI for interacting with PentestGPT via Ollama.

The goal of this module is to provide a desktop front-end that:
- Streams PentestGPT CLI output into a console-like widget.
- Lets the operator send commands and multi-line prompts back to the agent.
- Tracks files the tester intends to share with PentestGPT in future releases.
- Offers MCP (Model Context Protocol) configuration dialogs so ollmcp or other
  MCP clients can reuse the collected metadata when spawning tools or agents.

This implementation focuses on ease-of-use and extensibility. Future work can
wire the collected MCP configs and file attachments into specific tools or
remote servers without rewriting the UI scaffolding.
"""

from __future__ import annotations

import os
import re
import sys
from dataclasses import dataclass, field
from typing import Dict, List, Optional

from PySide6.QtCore import Qt, Signal
from PySide6.QtGui import QCloseEvent, QTextCursor
from PySide6.QtWidgets import (
    QApplication,
    QCheckBox,
    QDialog,
    QDialogButtonBox,
    QFileDialog,
    QFormLayout,
    QGridLayout,
    QGroupBox,
    QHBoxLayout,
    QInputDialog,
    QLabel,
    QLineEdit,
    QListWidget,
    QListWidgetItem,
    QMessageBox,
    QWidget,
    QPushButton,
    QPlainTextEdit,
    QSizePolicy,
    QSpinBox,
    QTabWidget,
    QTextEdit,
    QVBoxLayout,
)

from pentestgpt.session import PentestGPTSession

DEFAULT_TOOLS = [
    "filesystem",
    "shell",
    "web-search",
    "browser-control",
    "scan-runner",
]


@dataclass
class AgentSpec:
    name: str
    description: str = ""
    default_tools: List[str] = field(default_factory=list)


@dataclass
class MCPServerConfig:
    base_url: str = "http://localhost:4000"
    api_key: str = ""
    namespace: str = "default"
    max_connections: int = 1
    enabled_tools: Dict[str, bool] = field(
        default_factory=lambda: {tool: True for tool in DEFAULT_TOOLS}
    )
    agents: List[AgentSpec] = field(default_factory=list)


class MCPConfigDialog(QDialog):
    configSaved = Signal(MCPServerConfig)

    def __init__(self, config: MCPServerConfig | None = None, parent: QWidget | None = None):
        super().__init__(parent)
        self.setWindowTitle("Configure MCP Server")
        self._config = config or MCPServerConfig()
        self._agent_specs: List[AgentSpec] = list(self._config.agents)

        self.tabs = QTabWidget(self)
        self._build_server_tab()
        self._build_tools_tab()
        self._build_agents_tab()

        buttons = QDialogButtonBox(QDialogButtonBox.Save | QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)

        layout = QVBoxLayout(self)
        layout.addWidget(self.tabs)
        layout.addWidget(buttons)

    # ----- Tabs -----------------------------------------------------------------
    def _build_server_tab(self) -> None:
        tab = QWidget(self)
        layout = QFormLayout(tab)

        self.base_url_input = QLineEdit(self._config.base_url, tab)
        self.api_key_input = QLineEdit(self._config.api_key, tab)
        self.api_key_input.setEchoMode(QLineEdit.Password)
        self.namespace_input = QLineEdit(self._config.namespace, tab)
        self.max_conn_input = QSpinBox(tab)
        self.max_conn_input.setRange(1, 64)
        self.max_conn_input.setValue(self._config.max_connections)

        layout.addRow("Server URL", self.base_url_input)
        layout.addRow("API Key", self.api_key_input)
        layout.addRow("Namespace", self.namespace_input)
        layout.addRow("Max Connections", self.max_conn_input)
        self.tabs.addTab(tab, "Server")

    def _build_tools_tab(self) -> None:
        tab = QWidget(self)
        layout = QVBoxLayout(tab)
        self.tool_checkboxes: Dict[str, QCheckBox] = {}
        for tool in DEFAULT_TOOLS:
            checkbox = QCheckBox(tool, tab)
            checkbox.setChecked(self._config.enabled_tools.get(tool, False))
            self.tool_checkboxes[tool] = checkbox
            layout.addWidget(checkbox)
        layout.addStretch(1)
        self.tabs.addTab(tab, "Tools")

    def _build_agents_tab(self) -> None:
        tab = QWidget(self)
        layout = QVBoxLayout(tab)

        form = QFormLayout()
        self.agent_name_input = QLineEdit(tab)
        self.agent_desc_input = QTextEdit(tab)
        self.agent_desc_input.setFixedHeight(60)
        self.agent_tools_box: Dict[str, QCheckBox] = {}
        tools_box = QGroupBox("Default Tools", tab)
        tools_layout = QVBoxLayout(tools_box)
        for tool in DEFAULT_TOOLS:
            checkbox = QCheckBox(tool, tools_box)
            checkbox.setChecked(True)
            self.agent_tools_box[tool] = checkbox
            tools_layout.addWidget(checkbox)
        tools_layout.addStretch(1)

        add_agent_btn = QPushButton("Add Agent", tab)
        add_agent_btn.clicked.connect(self._add_agent)

        form.addRow("Name", self.agent_name_input)
        form.addRow("Description", self.agent_desc_input)
        form.addRow(tools_box)
        form.addRow(add_agent_btn)

        self.agent_list = QListWidget(tab)
        for agent in self._agent_specs:
            self.agent_list.addItem(self._format_agent(agent))

        layout.addLayout(form)
        layout.addWidget(QLabel("Configured Agents", tab))
        layout.addWidget(self.agent_list)
        self.tabs.addTab(tab, "Agents")

    # ----- Helpers --------------------------------------------------------------
    def _add_agent(self) -> None:
        name = self.agent_name_input.text().strip()
        if not name:
            return
        description = self.agent_desc_input.toPlainText().strip()
        tools = [tool for tool, box in self.agent_tools_box.items() if box.isChecked()]
        agent = AgentSpec(name=name, description=description, default_tools=tools)
        self._agent_specs.append(agent)
        self.agent_list.addItem(self._format_agent(agent))
        self.agent_name_input.clear()
        self.agent_desc_input.clear()
        for box in self.agent_tools_box.values():
            box.setChecked(True)

    @staticmethod
    def _format_agent(agent: AgentSpec) -> str:
        tools_display = ", ".join(agent.default_tools) if agent.default_tools else "none"
        return f"{agent.name} – tools: {tools_display}"

    # ----- Overrides ------------------------------------------------------------
    def accept(self) -> None:  # type: ignore[override]
        enabled_tools = {
            tool: checkbox.isChecked()
            for tool, checkbox in self.tool_checkboxes.items()
        }
        config = MCPServerConfig(
            base_url=self.base_url_input.text().strip() or self._config.base_url,
            api_key=self.api_key_input.text().strip(),
            namespace=self.namespace_input.text().strip() or "default",
            max_connections=self.max_conn_input.value(),
            enabled_tools=enabled_tools,
            agents=list(self._agent_specs),
        )
        self.configSaved.emit(config)
        self._config = config
        super().accept()


class PentestGPTWindow(QWidget):
    sessionEvent = Signal(dict)
    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("PentestGPT Ollama Console")
        self.resize(960, 720)
        self.session: Optional[PentestGPTSession] = None
        self.sessionEvent.connect(self._dispatch_session_event)

        self.attached_files: List[str] = []
        self.mcp_config = MCPServerConfig()
        self.pending_prompt: Optional[Dict[str, str]] = None

        self._build_ui()

    # ----- UI ------------------------------------------------------------------
    def _build_ui(self) -> None:
        layout = QVBoxLayout(self)

        # Session controls
        controls = QGridLayout()
        self.model_input = QLineEdit(os.getenv("OLLAMA_MODEL", "gpt-oss:20b"), self)
        self.base_url_input = QLineEdit(
            os.getenv("OLLAMA_BASE_URL", "http://localhost:11434"), self
        )
        self.start_button = QPushButton("Start Session", self)
        self.stop_button = QPushButton("Stop", self)
        self.stop_button.setEnabled(False)
        self.mcp_button = QPushButton("Configure MCP", self)

        self.start_button.clicked.connect(self.start_session)
        self.stop_button.clicked.connect(self.stop_session)
        self.mcp_button.clicked.connect(self.open_mcp_dialog)

        controls.addWidget(QLabel("Ollama Model"), 0, 0)
        controls.addWidget(self.model_input, 0, 1)
        controls.addWidget(QLabel("Base URL"), 0, 2)
        controls.addWidget(self.base_url_input, 0, 3)
        controls.addWidget(self.start_button, 1, 0)
        controls.addWidget(self.stop_button, 1, 1)
        controls.addWidget(self.mcp_button, 1, 2)

        layout.addLayout(controls)

        # Console view
        self.console = QPlainTextEdit(self)
        self.console.setReadOnly(True)
        self.console.setLineWrapMode(QPlainTextEdit.NoWrap)
        self.console.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        layout.addWidget(self.console)

        # Input row
        input_row = QHBoxLayout()
        self.input_box = QLineEdit(self)
        self.input_box.setEnabled(False)
        self.input_box.setPlaceholderText("Respond using the dialogs that appear during a session")
        self.send_button = QPushButton("Send", self)
        self.send_button.setEnabled(False)
        self.send_button.clicked.connect(self.send_command)
        input_row.addWidget(self.input_box, stretch=1)
        input_row.addWidget(self.send_button)
        layout.addLayout(input_row)

        # File attachments
        files_group = QGroupBox("Attached Files", self)
        files_layout = QVBoxLayout(files_group)
        self.file_list = QListWidget(files_group)
        attach_row = QHBoxLayout()
        attach_button = QPushButton("Attach Files", files_group)
        attach_button.clicked.connect(self.attach_files)
        clear_button = QPushButton("Clear", files_group)
        clear_button.clicked.connect(self.clear_files)
        attach_row.addWidget(attach_button)
        attach_row.addWidget(clear_button)
        files_layout.addWidget(self.file_list)
        files_layout.addLayout(attach_row)
        layout.addWidget(files_group)

        self.status_label = QLabel("Ready", self)
        layout.addWidget(self.status_label)

    # ----- Session lifecycle ---------------------------------------------------
    def start_session(self) -> None:
        if self.session is not None:
            self._append_console("Session already running. Stop it before starting a new one.\n")
            return

        model = self.model_input.text().strip() or "gpt-oss:20b"
        base_url = self.base_url_input.text().strip() or "http://localhost:11434"

        os.environ["OLLAMA_MODEL"] = model
        os.environ["OLLAMA_BASE_URL"] = base_url
        os.environ.setdefault("PENTESTGPT_USE_OLLAMA_DEFAULT", "true")

        use_ollama = os.environ.get("PENTESTGPT_USE_OLLAMA_DEFAULT", "true").lower() not in {"0", "false", "no"}
        if use_ollama:
            reasoning_model = parsing_model = "ollama"
        else:
            reasoning_model = os.environ.get("PENTESTGPT_REASONING_MODEL", "gpt-4o")
            parsing_model = os.environ.get("PENTESTGPT_PARSING_MODEL", reasoning_model)

        config = {
            "log_dir": os.environ.get("PENTESTGPT_LOG_DIR", "logs"),
            "reasoning_model": reasoning_model,
            "parsing_model": parsing_model,
            "useAPI": True,
            "use_langfuse_logging": os.environ.get("PENTESTGPT_USE_LANGFUSE", "false").lower()
            in {"1", "true", "yes"},
        }

        try:
            self.session = PentestGPTSession(config=config, event_callback=self.sessionEvent.emit)
            self.session.start()
        except Exception as exc:  # pragma: no cover - GUI feedback only
            self.session = None
            self._append_console(f"Failed to start PentestGPT: {exc}\n")
            return

        self.status_label.setText(f"Session starting on {model}")
        self.start_button.setEnabled(False)
        self.stop_button.setEnabled(True)

    def stop_session(self) -> None:
        if self.session is not None:
            self.session.stop()
            self.session = None
        self.status_label.setText("Session stopped")
        self.start_button.setEnabled(True)
        self.stop_button.setEnabled(False)

    # ----- IO handlers ---------------------------------------------------------
    def send_command(self) -> None:
        self._append_console("Use the pop-up dialogs to respond to PentestGPT prompts.\n")

    def _dispatch_session_event(self, event: Dict[str, object]) -> None:
        event_type = event.get("type")
        payload = event.get("payload", {})
        if event_type == "output":
            text = payload.get("text", "") if isinstance(payload, dict) else ""
            self._append_console(text)
        elif event_type == "state":
            self._handle_state_event(payload)
        elif event_type == "request":
            self._handle_request_event(event)
        elif event_type == "error":
            message = payload.get("message", "Unknown error") if isinstance(payload, dict) else str(payload)
            self._append_console(f"Error: {message}\n")
            self.status_label.setText("Error: see console")

    def _handle_state_event(self, payload: object) -> None:
        if not isinstance(payload, dict):
            return
        status = payload.get("status", "")
        if status == "starting":
            self.status_label.setText("Session starting...")
        elif status == "running":
            self.status_label.setText("Session running")
        elif status == "stopped":
            self.status_label.setText("Session stopped")
            self.start_button.setEnabled(True)
            self.stop_button.setEnabled(False)
            self.session = None

    def _handle_request_event(self, event: Dict[str, object]) -> None:
        if self.session is None:
            return
        payload = event.get("payload", {})
        if not isinstance(payload, dict):
            return
        request_id = event.get("request_id")
        if not isinstance(request_id, str):
            return
        kind = payload.get("kind")
        try:
            response = self._prompt_for_request(kind, payload)
        except Exception as exc:  # pragma: no cover - UI feedback only
            self._append_console(f"Request cancelled: {exc}\n")
            self.stop_session()
            return
        try:
            self.session.respond(request_id, response)
        except Exception as exc:  # pragma: no cover
            self._append_console(f"Failed to respond to request: {exc}\n")

    def _prompt_for_request(self, kind: Optional[str], payload: Dict[str, object]):
        if kind == "main_task":
            options = payload.get("options") or [
                "next",
                "more",
                "todo",
                "discuss",
                "google",
                "help",
                "quit",
            ]
            return self._prompt_choice("Main Task", "Choose the next command", options)
        if kind == "local_task":
            options = payload.get("options") or [
                "discuss",
                "brainstorm",
                "help",
                "google",
                "continue",
            ]
            return self._prompt_choice("Local Task", "Choose a sub-task command", options)
        if kind == "prompt_text":
            prompt = str(payload.get("prompt", "Input"))
            multiline = bool(payload.get("multiline", False))
            return self._prompt_text_dialog(prompt, multiline)
        if kind == "option_select":
            options = payload.get("options", [])
            descriptions = payload.get("descriptions", [])
            return self._option_select_dialog("Select Source", options, descriptions)
        if kind == "confirm":
            prompt = str(payload.get("prompt", "Continue?"))
            return self._confirm_dialog(prompt)
        if kind == "list_select":
            options = payload.get("options", [])
            prompt = str(payload.get("prompt", "Choose an option"))
            return self._list_select_dialog(prompt, options)
        if kind == "wait_for_enter":
            prompt = str(payload.get("prompt", "Press OK to continue"))
            self._info_dialog(prompt)
            return True
        raise RuntimeError(f"Unknown request type: {kind}")

    def _prompt_choice(self, title: str, prompt: str, options: List[str]) -> str:
        item, ok = QInputDialog.getItem(self, title, prompt, options, editable=False)
        if not ok or not item:
            raise RuntimeError("User cancelled selection")
        return str(item)

    def _prompt_text_dialog(self, prompt: str, multiline: bool) -> str:
        if not multiline:
            text, ok = QInputDialog.getText(self, "PentestGPT", prompt)
            if not ok:
                raise RuntimeError("Input was cancelled")
            return str(text)

        dialog = QDialog(self)
        dialog.setWindowTitle("PentestGPT Input")
        layout = QVBoxLayout(dialog)
        layout.addWidget(QLabel(prompt, dialog))
        text_edit = QPlainTextEdit(dialog)
        text_edit.setMinimumHeight(160)
        layout.addWidget(text_edit)
        buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel, dialog)
        layout.addWidget(buttons)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        if dialog.exec() == QDialog.Accepted:
            return text_edit.toPlainText().strip()
        raise RuntimeError("Input was cancelled")

    def _option_select_dialog(self, title: str, options: List[str], descriptions: List[str]) -> int:
        dialog = QDialog(self)
        dialog.setWindowTitle(title)
        layout = QVBoxLayout(dialog)
        list_widget = QListWidget(dialog)
        for idx, option in enumerate(options):
            desc = descriptions[idx] if idx < len(descriptions) else ""
            label = f"{option} – {desc}" if desc else option
            item = QListWidgetItem(label)
            item.setData(Qt.UserRole, idx)
            list_widget.addItem(item)
        layout.addWidget(list_widget)
        buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel, dialog)
        layout.addWidget(buttons)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        if dialog.exec() == QDialog.Accepted:
            current = list_widget.currentItem()
            if current is None:
                raise RuntimeError("No selection made")
            return int(current.data(Qt.UserRole))
        raise RuntimeError("Selection cancelled")

    def _confirm_dialog(self, prompt: str) -> bool:
        result = QMessageBox.question(self, "PentestGPT", prompt)
        return result == QMessageBox.Yes

    def _list_select_dialog(self, prompt: str, options: List[str]) -> Optional[int]:
        if not options:
            raise RuntimeError("No options available")
        formatted = "\n".join(f"{idx}. {label}" for idx, label in enumerate(options))
        message = f"{prompt}\n\n{formatted}"
        max_index = max(0, len(options) - 1)
        value, ok = QInputDialog.getInt(
            self,
            "PentestGPT",
            message,
            0,
            0,
            max_index,
        )
        if not ok:
            return None
        return int(value)

    def _info_dialog(self, message: str) -> None:
        QMessageBox.information(self, "PentestGPT", message)

    def _append_console(self, text: str) -> None:
        sanitized = self._sanitize_output(text)
        if not sanitized:
            return
        self.console.moveCursor(QTextCursor.End)
        self.console.insertPlainText(sanitized)
        self.console.moveCursor(QTextCursor.End)

    @staticmethod
    def _sanitize_output(text: str) -> str:
        """Strip control codes and redundant warning lines from CLI output."""
        if "Warning: Input is not a terminal (fd=0)." in text:
            return ""
        # Remove carriage returns/backspaces used by spinners and pseudo terminals.
        cleaned = text.replace("\r", "").replace("\x08", "")
        # Drop common ANSI escape sequences.
        ansi_escape = re.compile(r"\x1B\[[0-?]*[ -/]*[@-~]")
        cleaned = ansi_escape.sub("", cleaned)
        # script sometimes emits trailing null bytes when run with -q; strip them.
        cleaned = cleaned.replace("\x00", "")
        return cleaned

    # ----- File helpers --------------------------------------------------------
    def attach_files(self) -> None:
        file_paths, _ = QFileDialog.getOpenFileNames(self, "Select files")
        if not file_paths:
            return
        for path in file_paths:
            if path not in self.attached_files:
                self.attached_files.append(path)
                self.file_list.addItem(QListWidgetItem(path))
        self.status_label.setText(f"Tracking {len(self.attached_files)} file(s)")

    def clear_files(self) -> None:
        self.attached_files.clear()
        self.file_list.clear()
        self.status_label.setText("File attachments cleared")

    # ----- MCP dialog ----------------------------------------------------------
    def open_mcp_dialog(self) -> None:
        dialog = MCPConfigDialog(self.mcp_config, self)
        dialog.configSaved.connect(self._save_mcp_config)
        dialog.exec()

    def _save_mcp_config(self, config: MCPServerConfig) -> None:
        self.mcp_config = config
        agent_count = len(config.agents)
        enabled_tools = ", ".join(tool for tool, enabled in config.enabled_tools.items() if enabled) or "no tools"
        self._append_console(
            f"\nSaved MCP config: {config.base_url} · namespace={config.namespace} · tools={enabled_tools} · agents={agent_count}\n"
        )

    # ----- Qt overrides -------------------------------------------------------
    def closeEvent(self, event: QCloseEvent) -> None:  # type: ignore[override]
        self.stop_session()
        event.accept()


def main() -> None:
    app = QApplication(sys.argv)
    window = PentestGPTWindow()
    window.show()
    sys.exit(app.exec())


if __name__ == "__main__":
    main()

"""Minimal PySide6 GUI for interacting with PentestGPT via Ollama.

The goal of this module is to provide a desktop front-end that:
- Streams PentestGPT CLI output into a console-like widget.
- Lets the operator send commands and multi-line prompts back to the agent.
- Tracks files the tester intends to share with PentestGPT in future releases.
- Offers MCP (Model Context Protocol) configuration dialogs so ollmcp or other
  MCP clients can reuse the collected metadata when spawning tools or agents.

This implementation focuses on ease-of-use and extensibility. Future work can
wire the collected MCP configs and file attachments into specific tools or
remote servers without rewriting the UI scaffolding.
"""

from __future__ import annotations

import os
import re
import shutil
import sys
from dataclasses import dataclass, field
from typing import Dict, List

from PySide6.QtCore import Qt, QProcess, Signal
from PySide6.QtGui import QCloseEvent, QTextCursor
from PySide6.QtWidgets import (
    QApplication,
    QCheckBox,
    QDialog,
    QDialogButtonBox,
    QFileDialog,
    QFormLayout,
    QGridLayout,
    QGroupBox,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QListWidget,
    QListWidgetItem,
    QWidget,
    QPushButton,
    QPlainTextEdit,
    QSizePolicy,
    QSpinBox,
    QTabWidget,
    QTextEdit,
    QVBoxLayout,
)

DEFAULT_TOOLS = [
    "filesystem",
    "shell",
    "web-search",
    "browser-control",
    "scan-runner",
]


@dataclass
class AgentSpec:
    name: str
    description: str = ""
    default_tools: List[str] = field(default_factory=list)


@dataclass
class MCPServerConfig:
    base_url: str = "http://localhost:4000"
    api_key: str = ""
    namespace: str = "default"
    max_connections: int = 1
    enabled_tools: Dict[str, bool] = field(
        default_factory=lambda: {tool: True for tool in DEFAULT_TOOLS}
    )
    agents: List[AgentSpec] = field(default_factory=list)


class MCPConfigDialog(QDialog):
    configSaved = Signal(MCPServerConfig)

    def __init__(self, config: MCPServerConfig | None = None, parent: QWidget | None = None):
        super().__init__(parent)
        self.setWindowTitle("Configure MCP Server")
        self._config = config or MCPServerConfig()
        self._agent_specs: List[AgentSpec] = list(self._config.agents)

        self.tabs = QTabWidget(self)
        self._build_server_tab()
        self._build_tools_tab()
        self._build_agents_tab()

        buttons = QDialogButtonBox(QDialogButtonBox.Save | QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)

        layout = QVBoxLayout(self)
        layout.addWidget(self.tabs)
        layout.addWidget(buttons)

    # ----- Tabs -----------------------------------------------------------------
    def _build_server_tab(self) -> None:
        tab = QWidget(self)
        layout = QFormLayout(tab)

        self.base_url_input = QLineEdit(self._config.base_url, tab)
        self.api_key_input = QLineEdit(self._config.api_key, tab)
        self.api_key_input.setEchoMode(QLineEdit.Password)
        self.namespace_input = QLineEdit(self._config.namespace, tab)
        self.max_conn_input = QSpinBox(tab)
        self.max_conn_input.setRange(1, 64)
        self.max_conn_input.setValue(self._config.max_connections)

        layout.addRow("Server URL", self.base_url_input)
        layout.addRow("API Key", self.api_key_input)
        layout.addRow("Namespace", self.namespace_input)
        layout.addRow("Max Connections", self.max_conn_input)
        self.tabs.addTab(tab, "Server")

    def _build_tools_tab(self) -> None:
        tab = QWidget(self)
        layout = QVBoxLayout(tab)
        self.tool_checkboxes: Dict[str, QCheckBox] = {}
        for tool in DEFAULT_TOOLS:
            checkbox = QCheckBox(tool, tab)
            checkbox.setChecked(self._config.enabled_tools.get(tool, False))
            self.tool_checkboxes[tool] = checkbox
            layout.addWidget(checkbox)
        layout.addStretch(1)
        self.tabs.addTab(tab, "Tools")

    def _build_agents_tab(self) -> None:
        tab = QWidget(self)
        layout = QVBoxLayout(tab)

        form = QFormLayout()
        self.agent_name_input = QLineEdit(tab)
        self.agent_desc_input = QTextEdit(tab)
        self.agent_desc_input.setFixedHeight(60)
        self.agent_tools_box: Dict[str, QCheckBox] = {}
        tools_box = QGroupBox("Default Tools", tab)
        tools_layout = QVBoxLayout(tools_box)
        for tool in DEFAULT_TOOLS:
            checkbox = QCheckBox(tool, tools_box)
            checkbox.setChecked(True)
            self.agent_tools_box[tool] = checkbox
            tools_layout.addWidget(checkbox)
        tools_layout.addStretch(1)

        add_agent_btn = QPushButton("Add Agent", tab)
        add_agent_btn.clicked.connect(self._add_agent)

        form.addRow("Name", self.agent_name_input)
        form.addRow("Description", self.agent_desc_input)
        form.addRow(tools_box)
        form.addRow(add_agent_btn)

        self.agent_list = QListWidget(tab)
        for agent in self._agent_specs:
            self.agent_list.addItem(self._format_agent(agent))

        layout.addLayout(form)
        layout.addWidget(QLabel("Configured Agents", tab))
        layout.addWidget(self.agent_list)
        self.tabs.addTab(tab, "Agents")

    # ----- Helpers --------------------------------------------------------------
    def _add_agent(self) -> None:
        name = self.agent_name_input.text().strip()
        if not name:
            return
        description = self.agent_desc_input.toPlainText().strip()
        tools = [tool for tool, box in self.agent_tools_box.items() if box.isChecked()]
        agent = AgentSpec(name=name, description=description, default_tools=tools)
        self._agent_specs.append(agent)
        self.agent_list.addItem(self._format_agent(agent))
        self.agent_name_input.clear()
        self.agent_desc_input.clear()
        for box in self.agent_tools_box.values():
            box.setChecked(True)

    @staticmethod
    def _format_agent(agent: AgentSpec) -> str:
        tools_display = ", ".join(agent.default_tools) if agent.default_tools else "none"
        return f"{agent.name} – tools: {tools_display}"

    # ----- Overrides ------------------------------------------------------------
    def accept(self) -> None:  # type: ignore[override]
        enabled_tools = {
            tool: checkbox.isChecked()
            for tool, checkbox in self.tool_checkboxes.items()
        }
        config = MCPServerConfig(
            base_url=self.base_url_input.text().strip() or self._config.base_url,
            api_key=self.api_key_input.text().strip(),
            namespace=self.namespace_input.text().strip() or "default",
            max_connections=self.max_conn_input.value(),
            enabled_tools=enabled_tools,
            agents=list(self._agent_specs),
        )
        self.configSaved.emit(config)
        self._config = config
        super().accept()


class PentestGPTWindow(QWidget):
    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("PentestGPT Ollama Console")
        self.resize(960, 720)
        self.process = QProcess(self)
        self.python_interpreter = os.environ.get("PENTESTGPT_GUI_PYTHON", sys.executable)
        self.process.setProcessChannelMode(QProcess.MergedChannels)
        self.process.readyReadStandardOutput.connect(self._handle_stdout)
        self.process.readyReadStandardError.connect(self._handle_stderr)
        self.process.finished.connect(self._handle_finished)

        self.attached_files: List[str] = []
        self.mcp_config = MCPServerConfig()

        self._build_ui()

    # ----- UI ------------------------------------------------------------------
    def _build_ui(self) -> None:
        layout = QVBoxLayout(self)

        # Session controls
        controls = QGridLayout()
        self.model_input = QLineEdit(os.getenv("OLLAMA_MODEL", "gpt-oss:20b"), self)
        self.base_url_input = QLineEdit(
            os.getenv("OLLAMA_BASE_URL", "http://localhost:11434"), self
        )
        self.start_button = QPushButton("Start Session", self)
        self.stop_button = QPushButton("Stop", self)
        self.stop_button.setEnabled(False)
        self.mcp_button = QPushButton("Configure MCP", self)

        self.start_button.clicked.connect(self.start_session)
        self.stop_button.clicked.connect(self.stop_session)
        self.mcp_button.clicked.connect(self.open_mcp_dialog)

        controls.addWidget(QLabel("Ollama Model"), 0, 0)
        controls.addWidget(self.model_input, 0, 1)
        controls.addWidget(QLabel("Base URL"), 0, 2)
        controls.addWidget(self.base_url_input, 0, 3)
        controls.addWidget(self.start_button, 1, 0)
        controls.addWidget(self.stop_button, 1, 1)
        controls.addWidget(self.mcp_button, 1, 2)

        layout.addLayout(controls)

        # Console view
        self.console = QPlainTextEdit(self)
        self.console.setReadOnly(True)
        self.console.setLineWrapMode(QPlainTextEdit.NoWrap)
        self.console.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        layout.addWidget(self.console)

        # Input row
        input_row = QHBoxLayout()
        self.input_box = QLineEdit(self)
        self.input_box.returnPressed.connect(self.send_command)
        self.send_button = QPushButton("Send", self)
        self.send_button.clicked.connect(self.send_command)
        input_row.addWidget(self.input_box, stretch=1)
        input_row.addWidget(self.send_button)
        layout.addLayout(input_row)

        # File attachments
        files_group = QGroupBox("Attached Files", self)
        files_layout = QVBoxLayout(files_group)
        self.file_list = QListWidget(files_group)
        attach_row = QHBoxLayout()
        attach_button = QPushButton("Attach Files", files_group)
        attach_button.clicked.connect(self.attach_files)
        clear_button = QPushButton("Clear", files_group)
        clear_button.clicked.connect(self.clear_files)
        attach_row.addWidget(attach_button)
        attach_row.addWidget(clear_button)
        files_layout.addWidget(self.file_list)
        files_layout.addLayout(attach_row)
        layout.addWidget(files_group)

        self.status_label = QLabel("Ready", self)
        layout.addWidget(self.status_label)

    # ----- Session lifecycle ---------------------------------------------------
    def start_session(self) -> None:
        if self.process.state() != QProcess.NotRunning:
            self._append_console("Session already running. Stop it before starting a new one.\n")
            return

        model = self.model_input.text().strip() or "gpt-oss:20b"
        base_url = self.base_url_input.text().strip() or "http://localhost:11434"

        env = os.environ.copy()
        env["OLLAMA_MODEL"] = model
        env["OLLAMA_BASE_URL"] = base_url
        env.setdefault("PENTESTGPT_USE_OLLAMA_DEFAULT", "true")

        program, args = self._resolve_process_command(model)
        self.process.setProgram(program)
        self.process.setArguments(args)
        process_env = [f"{key}={value}" for key, value in env.items()]
        self.process.setEnvironment(process_env)
        self.process.start()
        if not self.process.waitForStarted(5000):
            self._append_console("Failed to start PentestGPT.\n")
            return

        self.status_label.setText(f"Session running on {model}")
        self.start_button.setEnabled(False)
        self.stop_button.setEnabled(True)

    def stop_session(self) -> None:
        if self.process.state() != QProcess.NotRunning:
            self.process.terminate()
            if not self.process.waitForFinished(3000):
                self.process.kill()
        self.status_label.setText("Session stopped")
        self.start_button.setEnabled(True)
        self.stop_button.setEnabled(False)

    def _resolve_process_command(self, model: str) -> tuple[str, List[str]]:
        """Return (program, args); default to PTY for cleaner prompt_toolkit behavior."""
        python_cmd = [self.python_interpreter, "-m", "pentestgpt.main", "--ollama", model]
        wrap_pref = os.environ.get("PENTESTGPT_GUI_WRAP_TTY", "1").lower()
        if os.name != "nt" and wrap_pref not in {"0", "false", "no"}:
            script_path = shutil.which("script")
            if script_path:
                # `script -q /dev/null <python_cmd>` allocates a PTY at the cost of noisy control chars.
                return script_path, ["-q", "/dev/null", *python_cmd]
        return python_cmd[0], python_cmd[1:]

    # ----- IO handlers ---------------------------------------------------------
    def send_command(self) -> None:
        text = self.input_box.text()
        if not text:
            return
        if self.process.state() == QProcess.NotRunning:
            self._append_console("Session is not running. Start it first.\n")
            return
        payload = text + "\n"
        self.process.write(payload.encode("utf-8"))
        self.input_box.clear()

    def _handle_stdout(self) -> None:
        data = bytes(self.process.readAllStandardOutput()).decode("utf-8", errors="replace")
        self._append_console(data)

    def _handle_stderr(self) -> None:
        data = bytes(self.process.readAllStandardError()).decode("utf-8", errors="replace")
        self._append_console(data)

    def _handle_finished(self, code: int, _status: QProcess.ExitStatus) -> None:
        self._append_console(f"\nPentestGPT exited with code {code}.\n")
        self.start_button.setEnabled(True)
        self.stop_button.setEnabled(False)
        self.status_label.setText("Session stopped")

    def _append_console(self, text: str) -> None:
        sanitized = self._sanitize_output(text)
        if not sanitized:
            return
        self.console.moveCursor(QTextCursor.End)
        self.console.insertPlainText(sanitized)
        self.console.moveCursor(QTextCursor.End)

    @staticmethod
    def _sanitize_output(text: str) -> str:
        """Strip control codes and redundant warning lines from CLI output."""
        if "Warning: Input is not a terminal (fd=0)." in text:
            return ""
        # Remove carriage returns/backspaces used by spinners and pseudo terminals.
        cleaned = text.replace("\r", "").replace("\x08", "")
        # Drop common ANSI escape sequences.
        ansi_escape = re.compile(r"\x1B\[[0-?]*[ -/]*[@-~]")
        cleaned = ansi_escape.sub("", cleaned)
        # script sometimes emits trailing null bytes when run with -q; strip them.
        cleaned = cleaned.replace("\x00", "")
        return cleaned

    # ----- File helpers --------------------------------------------------------
    def attach_files(self) -> None:
        file_paths, _ = QFileDialog.getOpenFileNames(self, "Select files")
        if not file_paths:
            return
        for path in file_paths:
            if path not in self.attached_files:
                self.attached_files.append(path)
                self.file_list.addItem(QListWidgetItem(path))
        self.status_label.setText(f"Tracking {len(self.attached_files)} file(s)")

    def clear_files(self) -> None:
        self.attached_files.clear()
        self.file_list.clear()
        self.status_label.setText("File attachments cleared")

    # ----- MCP dialog ----------------------------------------------------------
    def open_mcp_dialog(self) -> None:
        dialog = MCPConfigDialog(self.mcp_config, self)
        dialog.configSaved.connect(self._save_mcp_config)
        dialog.exec()

    def _save_mcp_config(self, config: MCPServerConfig) -> None:
        self.mcp_config = config
        agent_count = len(config.agents)
        enabled_tools = ", ".join(tool for tool, enabled in config.enabled_tools.items() if enabled) or "no tools"
        self._append_console(
            f"\nSaved MCP config: {config.base_url} · namespace={config.namespace} · tools={enabled_tools} · agents={agent_count}\n"
        )

    # ----- Qt overrides -------------------------------------------------------
    def closeEvent(self, event: QCloseEvent) -> None:  # type: ignore[override]
        self.stop_session()
        event.accept()


def main() -> None:
    app = QApplication(sys.argv)
    window = PentestGPTWindow()
    window.show()
    sys.exit(app.exec())


if __name__ == "__main__":
    main()

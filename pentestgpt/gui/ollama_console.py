"""Minimal PySide6 GUI for interacting with PentestGPT via Ollama.

The goal of this module is to provide a desktop front-end that:
- Streams PentestGPT CLI output into a console-like widget.
- Lets the operator send commands and multi-line prompts back to the agent.
- Tracks files the tester intends to share with PentestGPT in future releases.
- Offers MCP (Model Context Protocol) configuration dialogs so ollmcp or other
  MCP clients can reuse the collected metadata when spawning tools or agents.

This implementation focuses on ease-of-use and extensibility. Future work can
wire the collected MCP configs and file attachments into specific tools or
remote servers without rewriting the UI scaffolding.
"""

from __future__ import annotations

import os
import re
import sys
from dataclasses import dataclass, field
from typing import Dict, List, Optional

from PySide6.QtCore import Qt, Signal, QTimer
from PySide6.QtGui import QCloseEvent, QTextCursor
from PySide6.QtWidgets import (
    QApplication,
    QCheckBox,
    QDialog,
    QDialogButtonBox,
    QFileDialog,
    QFormLayout,
    QGridLayout,
    QGroupBox,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QListWidget,
    QListWidgetItem,
    QWidget,
    QPushButton,
    QPlainTextEdit,
    QSizePolicy,
    QSpinBox,
    QTabWidget,
    QTextEdit,
    QVBoxLayout,
)

from pentestgpt.session import PentestGPTSession

DEFAULT_TOOLS = [
    "filesystem",
    "shell",
    "web-search",
    "browser-control",
    "scan-runner",
]


@dataclass
class AgentSpec:
    name: str
    description: str = ""
    default_tools: List[str] = field(default_factory=list)


@dataclass
class MCPServerConfig:
    base_url: str = "http://localhost:4000"
    api_key: str = ""
    namespace: str = "default"
    max_connections: int = 1
    enabled_tools: Dict[str, bool] = field(
        default_factory=lambda: {tool: True for tool in DEFAULT_TOOLS}
    )
    agents: List[AgentSpec] = field(default_factory=list)


class MCPConfigDialog(QDialog):
    configSaved = Signal(MCPServerConfig)

    def __init__(self, config: MCPServerConfig | None = None, parent: QWidget | None = None):
        super().__init__(parent)
        self.setWindowTitle("Configure MCP Server")
        self._config = config or MCPServerConfig()
        self._agent_specs: List[AgentSpec] = list(self._config.agents)

        self.tabs = QTabWidget(self)
        self._build_server_tab()
        self._build_tools_tab()
        self._build_agents_tab()

        buttons = QDialogButtonBox(QDialogButtonBox.Save | QDialogButtonBox.Cancel)
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)

        layout = QVBoxLayout(self)
        layout.addWidget(self.tabs)
        layout.addWidget(buttons)

    # ----- Tabs -----------------------------------------------------------------
    def _build_server_tab(self) -> None:
        tab = QWidget(self)
        layout = QFormLayout(tab)

        self.base_url_input = QLineEdit(self._config.base_url, tab)
        self.api_key_input = QLineEdit(self._config.api_key, tab)
        self.api_key_input.setEchoMode(QLineEdit.Password)
        self.namespace_input = QLineEdit(self._config.namespace, tab)
        self.max_conn_input = QSpinBox(tab)
        self.max_conn_input.setRange(1, 64)
        self.max_conn_input.setValue(self._config.max_connections)

        layout.addRow("Server URL", self.base_url_input)
        layout.addRow("API Key", self.api_key_input)
        layout.addRow("Namespace", self.namespace_input)
        layout.addRow("Max Connections", self.max_conn_input)
        self.tabs.addTab(tab, "Server")

    def _build_tools_tab(self) -> None:
        tab = QWidget(self)
        layout = QVBoxLayout(tab)
        self.tool_checkboxes: Dict[str, QCheckBox] = {}
        for tool in DEFAULT_TOOLS:
            checkbox = QCheckBox(tool, tab)
            checkbox.setChecked(self._config.enabled_tools.get(tool, False))
            self.tool_checkboxes[tool] = checkbox
            layout.addWidget(checkbox)
        layout.addStretch(1)
        self.tabs.addTab(tab, "Tools")

    def _build_agents_tab(self) -> None:
        tab = QWidget(self)
        layout = QVBoxLayout(tab)

        form = QFormLayout()
        self.agent_name_input = QLineEdit(tab)
        self.agent_desc_input = QTextEdit(tab)
        self.agent_desc_input.setFixedHeight(60)
        self.agent_tools_box: Dict[str, QCheckBox] = {}
        tools_box = QGroupBox("Default Tools", tab)
        tools_layout = QVBoxLayout(tools_box)
        for tool in DEFAULT_TOOLS:
            checkbox = QCheckBox(tool, tools_box)
            checkbox.setChecked(True)
            self.agent_tools_box[tool] = checkbox
            tools_layout.addWidget(checkbox)
        tools_layout.addStretch(1)

        add_agent_btn = QPushButton("Add Agent", tab)
        add_agent_btn.clicked.connect(self._add_agent)

        form.addRow("Name", self.agent_name_input)
        form.addRow("Description", self.agent_desc_input)
        form.addRow(tools_box)
        form.addRow(add_agent_btn)

        self.agent_list = QListWidget(tab)
        for agent in self._agent_specs:
            self.agent_list.addItem(self._format_agent(agent))

        layout.addLayout(form)
        layout.addWidget(QLabel("Configured Agents", tab))
        layout.addWidget(self.agent_list)
        self.tabs.addTab(tab, "Agents")

    # ----- Helpers --------------------------------------------------------------
    def _add_agent(self) -> None:
        name = self.agent_name_input.text().strip()
        if not name:
            return
        description = self.agent_desc_input.toPlainText().strip()
        tools = [tool for tool, box in self.agent_tools_box.items() if box.isChecked()]
        agent = AgentSpec(name=name, description=description, default_tools=tools)
        self._agent_specs.append(agent)
        self.agent_list.addItem(self._format_agent(agent))
        self.agent_name_input.clear()
        self.agent_desc_input.clear()
        for box in self.agent_tools_box.values():
            box.setChecked(True)

    @staticmethod
    def _format_agent(agent: AgentSpec) -> str:
        tools_display = ", ".join(agent.default_tools) if agent.default_tools else "none"
        return f"{agent.name} – tools: {tools_display}"

    # ----- Overrides ------------------------------------------------------------
    def accept(self) -> None:  # type: ignore[override]
        enabled_tools = {
            tool: checkbox.isChecked()
            for tool, checkbox in self.tool_checkboxes.items()
        }
        config = MCPServerConfig(
            base_url=self.base_url_input.text().strip() or self._config.base_url,
            api_key=self.api_key_input.text().strip(),
            namespace=self.namespace_input.text().strip() or "default",
            max_connections=self.max_conn_input.value(),
            enabled_tools=enabled_tools,
            agents=list(self._agent_specs),
        )
        self.configSaved.emit(config)
        self._config = config
        super().accept()


class PentestGPTWindow(QWidget):
    sessionEvent = Signal(dict)
    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("PentestGPT Ollama Console")
        self.resize(960, 720)
        self.session: Optional[PentestGPTSession] = None
        self.sessionEvent.connect(self._dispatch_session_event)

        self.attached_files: List[str] = []
        self.mcp_config = MCPServerConfig()
        self.current_request_id: Optional[str] = None
        self.current_request_kind: Optional[str] = None
        self.current_request_payload: Dict[str, object] = {}
        self.awaiting_user = False
        self.spinner_frames = ["⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"]
        self.spinner_index = 0
        self.spinner_timer = QTimer(self)
        self.spinner_timer.timeout.connect(self._advance_spinner)

        self._build_ui()

    # ----- UI ------------------------------------------------------------------
    def _build_ui(self) -> None:
        layout = QVBoxLayout(self)

        # Session controls
        controls = QGridLayout()
        self.model_input = QLineEdit(os.getenv("OLLAMA_MODEL", "gpt-oss:20b"), self)
        self.base_url_input = QLineEdit(
            os.getenv("OLLAMA_BASE_URL", "http://localhost:11434"), self
        )
        self.start_button = QPushButton("Start Session", self)
        self.stop_button = QPushButton("Stop", self)
        self.stop_button.setEnabled(False)
        self.mcp_button = QPushButton("Configure MCP", self)

        self.start_button.clicked.connect(self.start_session)
        self.stop_button.clicked.connect(self.stop_session)
        self.mcp_button.clicked.connect(self.open_mcp_dialog)

        controls.addWidget(QLabel("Ollama Model"), 0, 0)
        controls.addWidget(self.model_input, 0, 1)
        controls.addWidget(QLabel("Base URL"), 0, 2)
        controls.addWidget(self.base_url_input, 0, 3)
        controls.addWidget(self.start_button, 1, 0)
        controls.addWidget(self.stop_button, 1, 1)
        controls.addWidget(self.mcp_button, 1, 2)

        layout.addLayout(controls)

        # Console view
        self.console = QPlainTextEdit(self)
        self.console.setReadOnly(True)
        self.console.setLineWrapMode(QPlainTextEdit.NoWrap)
        self.console.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        layout.addWidget(self.console)

        # Inline request panel
        self.request_group = QGroupBox("Pending Prompt", self)
        self.request_group.setVisible(False)
        request_layout = QVBoxLayout(self.request_group)
        self.request_prompt = QLabel("PentestGPT prompts will appear here.", self.request_group)
        self.request_prompt.setWordWrap(True)
        request_layout.addWidget(self.request_prompt)

        self.request_options = QListWidget(self.request_group)
        self.request_options.setSelectionMode(QListWidget.SingleSelection)
        self.request_options.itemDoubleClicked.connect(lambda *_: self._handle_submit_clicked())
        self.request_options.setVisible(False)
        request_layout.addWidget(self.request_options)

        self.request_line_input = QLineEdit(self.request_group)
        self.request_line_input.setVisible(False)
        request_layout.addWidget(self.request_line_input)

        self.request_text_input = QPlainTextEdit(self.request_group)
        self.request_text_input.setVisible(False)
        self.request_text_input.setMinimumHeight(160)
        request_layout.addWidget(self.request_text_input)

        self.request_info_label = QLabel("", self.request_group)
        self.request_info_label.setWordWrap(True)
        self.request_info_label.setVisible(False)
        request_layout.addWidget(self.request_info_label)

        button_row = QHBoxLayout()
        self.request_submit = QPushButton("Submit", self.request_group)
        self.request_submit.clicked.connect(self._handle_submit_clicked)
        self.request_cancel = QPushButton("Cancel", self.request_group)
        self.request_cancel.clicked.connect(self._handle_cancel_request)
        self.request_yes = QPushButton("Yes", self.request_group)
        self.request_yes.clicked.connect(lambda: self._handle_confirm_response(True))
        self.request_no = QPushButton("No", self.request_group)
        self.request_no.clicked.connect(lambda: self._handle_confirm_response(False))
        self.request_continue = QPushButton("Continue", self.request_group)
        self.request_continue.clicked.connect(self._handle_continue_request)
        for button in (
            self.request_submit,
            self.request_cancel,
            self.request_yes,
            self.request_no,
            self.request_continue,
        ):
            button.setVisible(False)
            button_row.addWidget(button)
        request_layout.addLayout(button_row)
        layout.addWidget(self.request_group)

        # File attachments
        files_group = QGroupBox("Attached Files", self)
        files_layout = QVBoxLayout(files_group)
        self.file_list = QListWidget(files_group)
        attach_row = QHBoxLayout()
        attach_button = QPushButton("Attach Files", files_group)
        attach_button.clicked.connect(self.attach_files)
        clear_button = QPushButton("Clear", files_group)
        clear_button.clicked.connect(self.clear_files)
        attach_row.addWidget(attach_button)
        attach_row.addWidget(clear_button)
        files_layout.addWidget(self.file_list)
        files_layout.addLayout(attach_row)
        layout.addWidget(files_group)

        status_row = QHBoxLayout()
        self.status_label = QLabel("Ready", self)
        self.spinner_label = QLabel("", self)
        self.spinner_label.setMinimumWidth(24)
        status_row.addWidget(self.status_label)
        status_row.addStretch(1)
        status_row.addWidget(self.spinner_label)
        layout.addLayout(status_row)

    # ----- Session lifecycle ---------------------------------------------------
    def start_session(self) -> None:
        if self.session is not None:
            self._append_console("Session already running. Stop it before starting a new one.\n")
            return

        model = self.model_input.text().strip() or "gpt-oss:20b"
        base_url = self.base_url_input.text().strip() or "http://localhost:11434"

        os.environ["OLLAMA_MODEL"] = model
        os.environ["OLLAMA_BASE_URL"] = base_url
        os.environ.setdefault("PENTESTGPT_USE_OLLAMA_DEFAULT", "true")

        use_ollama = os.environ.get("PENTESTGPT_USE_OLLAMA_DEFAULT", "true").lower() not in {"0", "false", "no"}
        if use_ollama:
            reasoning_model = parsing_model = "ollama"
        else:
            reasoning_model = os.environ.get("PENTESTGPT_REASONING_MODEL", "gpt-4o")
            parsing_model = os.environ.get("PENTESTGPT_PARSING_MODEL", reasoning_model)

        config = {
            "log_dir": os.environ.get("PENTESTGPT_LOG_DIR", "logs"),
            "reasoning_model": reasoning_model,
            "parsing_model": parsing_model,
            "useAPI": True,
            "use_langfuse_logging": os.environ.get("PENTESTGPT_USE_LANGFUSE", "false").lower()
            in {"1", "true", "yes"},
        }

        try:
            self.session = PentestGPTSession(config=config, event_callback=self.sessionEvent.emit)
            self.session.start()
        except Exception as exc:  # pragma: no cover - GUI feedback only
            self.session = None
            self._append_console(f"Failed to start PentestGPT: {exc}\n")
            return

        self.status_label.setText(f"Session starting on {model}")
        self.start_button.setEnabled(False)
        self.stop_button.setEnabled(True)

    def stop_session(self) -> None:
        if self.session is not None:
            self.session.stop()
            self.session = None
        self.status_label.setText("Session stopped")
        self.start_button.setEnabled(True)
        self.stop_button.setEnabled(False)
        self.awaiting_user = False
        self._clear_request_panel()
        self._set_spinner(False)

    # ----- IO handlers ---------------------------------------------------------
    def _dispatch_session_event(self, event: Dict[str, object]) -> None:
        event_type = event.get("type")
        payload = event.get("payload", {})
        if event_type == "output":
            text = payload.get("text", "") if isinstance(payload, dict) else ""
            self._append_console(text)
        elif event_type == "state":
            self._handle_state_event(payload)
        elif event_type == "request":
            self._handle_request_event(event)
        elif event_type == "error":
            message = payload.get("message", "Unknown error") if isinstance(payload, dict) else str(payload)
            self._append_console(f"Error: {message}\n")
            self.status_label.setText("Error: see console")

    def _handle_state_event(self, payload: object) -> None:
        if not isinstance(payload, dict):
            return
        status = payload.get("status", "")
        if status == "starting":
            self.status_label.setText("Session starting...")
            self.awaiting_user = False
            self._update_spinner_state()
        elif status == "running":
            self.status_label.setText("Session running")
            if not self.awaiting_user:
                self._update_spinner_state()
        elif status == "stopped":
            self.status_label.setText("Session stopped")
            self.start_button.setEnabled(True)
            self.stop_button.setEnabled(False)
            self.session = None
            self.awaiting_user = False
            self._clear_request_panel()
            self._set_spinner(False)

    def _handle_request_event(self, event: Dict[str, object]) -> None:
        if self.session is None:
            return
        payload = event.get("payload", {})
        if not isinstance(payload, dict):
            return
        request_id = event.get("request_id")
        if not isinstance(request_id, str):
            return
        kind = str(payload.get("kind", ""))
        self.awaiting_user = True
        self._update_spinner_state()
        self._show_request_panel(kind, payload, request_id)

    def _show_request_panel(self, kind: str, payload: Dict[str, object], request_id: str) -> None:
        self.current_request_id = request_id
        self.current_request_kind = kind
        self.current_request_payload = payload
        self.request_group.setVisible(True)
        self._reset_request_controls()

        prompt_text = str(
            payload.get(
                "prompt",
                {
                    "main_task": "Select the next PentestGPT action.",
                    "local_task": "Select a local sub-task command.",
                    "option_select": payload.get("title", "Select an option"),
                    "wait_for_enter": "PentestGPT is paused.",
                }.get(kind, "PentestGPT requested input."),
            )
        )
        self.request_prompt.setText(prompt_text)
        self._append_console(f"\n[Prompt] {prompt_text}\n")

        if kind in {"main_task", "local_task"}:
            options = payload.get("options") or []
            if not options:
                options = (
                    ["next", "more", "todo", "discuss", "google", "help", "quit"]
                    if kind == "main_task"
                    else ["discuss", "brainstorm", "help", "google", "continue"]
                )
            self._populate_option_list(options, return_indices=False)
            self._set_action_buttons(submit_cancel=True)
            return

        if kind == "prompt_text":
            multiline = bool(payload.get("multiline", False))
            if multiline:
                self.request_text_input.setVisible(True)
                self.request_text_input.setFocus()
            else:
                self.request_line_input.setVisible(True)
                self.request_line_input.setFocus()
            self._set_action_buttons(submit_cancel=True)
            return

        if kind == "option_select":
            options = payload.get("options", [])
            descriptions = payload.get("descriptions", [])
            display_items = []
            for idx, option in enumerate(options):
                desc = descriptions[idx] if idx < len(descriptions) else ""
                label = f"{option} – {desc}" if desc else str(option)
                display_items.append((label, idx))
            self._populate_option_list(display_items, return_indices=True)
            self._set_action_buttons(submit_cancel=True)
            return

        if kind == "list_select":
            options = payload.get("options", [])
            display_items = [(f"{idx}. {label}", idx) for idx, label in enumerate(options)]
            self._populate_option_list(display_items, return_indices=True)
            self._set_action_buttons(submit_cancel=True)
            return

        if kind == "confirm":
            self.request_info_label.setText("Confirm to continue or decline to skip.")
            self.request_info_label.setVisible(True)
            self._set_action_buttons(confirm=True)
            return

        if kind == "wait_for_enter":
            message = payload.get("prompt") or "Press continue when ready."
            self.request_info_label.setText(str(message))
            self.request_info_label.setVisible(True)
            self._set_action_buttons(continue_only=True)
            return

        self._append_console(f"Unsupported request type: {kind}\n")

    def _reset_request_controls(self) -> None:
        self.request_options.clear()
        self.request_options.hide()
        self.request_line_input.clear()
        self.request_line_input.hide()
        self.request_text_input.clear()
        self.request_text_input.hide()
        self.request_info_label.clear()
        self.request_info_label.hide()
        for button in (
            self.request_submit,
            self.request_cancel,
            self.request_yes,
            self.request_no,
            self.request_continue,
        ):
            button.setVisible(False)

    def _populate_option_list(self, items, return_indices: bool) -> None:
        self.request_options.clear()
        for entry in items:
            if isinstance(entry, tuple):
                label, value = entry
            else:
                label, value = entry, entry
            item = QListWidgetItem(str(label))
            if return_indices:
                item.setData(Qt.UserRole, int(value))
            else:
                item.setData(Qt.UserRole, str(value))
            self.request_options.addItem(item)
        if self.request_options.count() > 0:
            self.request_options.setCurrentRow(0)
        self.request_options.setVisible(True)

    def _set_action_buttons(
        self,
        *,
        submit_cancel: bool = False,
        confirm: bool = False,
        continue_only: bool = False,
    ) -> None:
        if submit_cancel:
            self.request_submit.setVisible(True)
            self.request_cancel.setVisible(True)
        elif confirm:
            self.request_yes.setVisible(True)
            self.request_no.setVisible(True)
        elif continue_only:
            self.request_continue.setVisible(True)

    def _handle_submit_clicked(self) -> None:
        if self.session is None or not self.current_request_id:
            return
        try:
            value = self._collect_request_response()
        except ValueError as exc:
            self._append_console(f"{exc}\n")
            return
        self._send_response(value)

    def _collect_request_response(self):
        kind = self.current_request_kind or ""
        if kind in {"main_task", "local_task"}:
            item = self.request_options.currentItem()
            if item is None:
                raise ValueError("Select an option before submitting.")
            return item.data(Qt.UserRole) or item.text()
        if kind == "prompt_text":
            multiline = bool(self.current_request_payload.get("multiline", False))
            if multiline:
                text = self.request_text_input.toPlainText().strip()
            else:
                text = self.request_line_input.text().strip()
            if not text:
                raise ValueError("Please enter a response before submitting.")
            return text
        if kind == "option_select":
            item = self.request_options.currentItem()
            if item is None:
                raise ValueError("Select a source before submitting.")
            return int(item.data(Qt.UserRole))
        if kind == "list_select":
            item = self.request_options.currentItem()
            if item is None:
                return None
            return int(item.data(Qt.UserRole))
        raise ValueError("Unsupported submit action for this request.")

    def _handle_cancel_request(self) -> None:
        self._append_console("Request cancelled. Stopping session.\n")
        self.stop_session()
        self._clear_request_panel()

    def _handle_confirm_response(self, value: bool) -> None:
        self._send_response(value)

    def _handle_continue_request(self) -> None:
        self._send_response(True)

    def _send_response(self, value) -> None:
        if self.session is None or not self.current_request_id:
            return
        try:
            self.session.respond(self.current_request_id, value)
        except Exception as exc:  # pragma: no cover - UI feedback only
            self._append_console(f"Failed to respond to request: {exc}\n")
            return
        self._append_console(f"[Response] {value}\n")
        self._clear_request_panel()
        self.awaiting_user = False
        self._update_spinner_state()

    def _clear_request_panel(self) -> None:
        self.current_request_id = None
        self.current_request_kind = None
        self.current_request_payload = {}
        self._reset_request_controls()
        self.request_group.setVisible(False)

    def _set_spinner(self, active: bool) -> None:
        if active:
            if not self.spinner_timer.isActive():
                self.spinner_timer.start(120)
        else:
            if self.spinner_timer.isActive():
                self.spinner_timer.stop()
            self.spinner_label.setText("")

    def _advance_spinner(self) -> None:
        if not self.spinner_timer.isActive():
            return
        frame = self.spinner_frames[self.spinner_index % len(self.spinner_frames)]
        self.spinner_label.setText(frame)
        self.spinner_index = (self.spinner_index + 1) % len(self.spinner_frames)

    def _update_spinner_state(self) -> None:
        if self.session is not None and not self.awaiting_user:
            self._set_spinner(True)
        else:
            self._set_spinner(False)

    def _append_console(self, text: str) -> None:
        sanitized = self._sanitize_output(text)
        if not sanitized:
            return
        self.console.moveCursor(QTextCursor.End)
        self.console.insertPlainText(sanitized)
        self.console.moveCursor(QTextCursor.End)

    @staticmethod
    def _sanitize_output(text: str) -> str:
        """Strip control codes and redundant warning lines from CLI output."""
        if "Warning: Input is not a terminal (fd=0)." in text:
            return ""
        # Remove carriage returns/backspaces used by spinners and pseudo terminals.
        cleaned = text.replace("\r", "").replace("\x08", "")
        # Drop common ANSI escape sequences.
        ansi_escape = re.compile(r"\x1B\[[0-?]*[ -/]*[@-~]")
        cleaned = ansi_escape.sub("", cleaned)
        # script sometimes emits trailing null bytes when run with -q; strip them.
        cleaned = cleaned.replace("\x00", "")
        return cleaned

    # ----- File helpers --------------------------------------------------------
    def attach_files(self) -> None:
        file_paths, _ = QFileDialog.getOpenFileNames(self, "Select files")
        if not file_paths:
            return
        for path in file_paths:
            if path not in self.attached_files:
                self.attached_files.append(path)
                self.file_list.addItem(QListWidgetItem(path))
        self.status_label.setText(f"Tracking {len(self.attached_files)} file(s)")

    def clear_files(self) -> None:
        self.attached_files.clear()
        self.file_list.clear()
        self.status_label.setText("File attachments cleared")

    # ----- MCP dialog ----------------------------------------------------------
    def open_mcp_dialog(self) -> None:
        dialog = MCPConfigDialog(self.mcp_config, self)
        dialog.configSaved.connect(self._save_mcp_config)
        dialog.exec()

    def _save_mcp_config(self, config: MCPServerConfig) -> None:
        self.mcp_config = config
        agent_count = len(config.agents)
        enabled_tools = ", ".join(tool for tool, enabled in config.enabled_tools.items() if enabled) or "no tools"
        self._append_console(
            f"\nSaved MCP config: {config.base_url} · namespace={config.namespace} · tools={enabled_tools} · agents={agent_count}\n"
        )

    # ----- Qt overrides -------------------------------------------------------
    def closeEvent(self, event: QCloseEvent) -> None:  # type: ignore[override]
        self.stop_session()
        event.accept()


def main() -> None:
    app = QApplication(sys.argv)
    window = PentestGPTWindow()
    window.show()
    sys.exit(app.exec())


if __name__ == "__main__":
    main()
